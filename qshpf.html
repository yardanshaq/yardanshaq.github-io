<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no">
    <title>parasur</title>
    <style>

        body {
            background: #131115;
        }

        #c1 {
            background: #fbf7fe;
        }

        #btn {
            position: fixed;
            left: 0px;
            top: 0px;
        }

        #c1 {
            position: fixed;
            left: 0px;
            top: 0px;
        }

        #config {
            position: fixed;
            left: 0px;
            top: 30px;
            display: none;
        }
    </style>
</head>
<body style="overflow-x:hidden;overflow-y:hidden">
    <canvas id="c1" width="512" height="512">
        <span>不支持canvas浏览器</span>
    </canvas>
    <button id="btn">CONFIG</button>
    <div id="config">
        <textarea name="" id="kernel" cols="50" rows="10"></textarea>
        <br />
        <button id="apply">APPLY</button>
        <button id="cancle">CANCLE</button>
    </div>
    <script>
        var cx, cy;
        var canvas = document.getElementById("c1");
        var gl, glview, glproject;
        var md = 0,mx,my;
        var mx = 0, my = 0, mx1 = 0, my1 = 0, lasttimen = 0;
        var ml = 0, mr = 0, mm = 0;
        var len = 6.0;
        var ang1 = 1.57;
        var ang2 = 1.57;
        var cenx = 2.72;
        var ceny = 0.5;
        var cenz = 1.57;
        var vbuffer=[], cbuffer=[], nbuffer=[];
        var points = [];

        var MapSize =16384;
        var noqi = 16;
        var Noq = 256;
        var coslim = 1.0 - 1.0 / 4, aculim = 0.01;

        var quaMap = Array();
        var Mapbot = Array();
        var Maprig = Array();
        var Maptop = Array();
        var Maplef = Array();
        var Mapfat = Array();
        var qual = Array();
        var quau = Array();
        var quav = Array();
        var end = 0;
        var s =
            "getv = (function () {\n" +
            "	conf = {\n" +
            "		\"repeat\": 30,\n" +
            "		\"kpoint\": 256,\n" +
            "		\"atom\": [\"a1\", \"a2\", \"b1\", \"b2\"],\n" +
            "		\"hopping\": {\n" +
            "			\"t\": {\n" +
            "				\"value\": 1,\n" +
            "				\"pair\": [\n" +
            "					[\"a1\", \"b1\", 0, 0, 1, 0],\n" +
            "					[\"b1\", \"a1\", 1, 0, 1, 0],\n" +
            "					[\"b1\", \"a1\", 0, 1, 1, 0],\n" +
            "					[\"a2\", \"b2\", 0, 0, 1, 0],\n" +
            "					[\"b2\", \"a2\", 1, 0, 1, 0],\n" +
            "					[\"b2\", \"a2\", 0, 1, 1, 0]\n" +
            "				]\n" +
            "			},\n" +
            "			\"tso\": {\n" +
            "				\"value\": 0.06,\n" +
            "				\"pair\": [\n" +
            "					[\"a1\", \"a1\", 1, 0, 0, 1],\n" +
            "					[\"a1\", \"a1\", 0, 1, 0, -1],\n" +
            "					[\"a1\", \"a1\", -1, 1, 0, 1],\n" +
            "					[\"b1\", \"b1\", 1, 0, 0, -1],\n" +
            "					[\"b1\", \"b1\", 0, 1, 0, 1],\n" +
            "					[\"b1\", \"b1\", -1, 1, 0, -1],\n" +
            "					[\"a2\", \"a2\", 1, 0, 0, -1],\n" +
            "					[\"a2\", \"a2\", 0, 1, 0, 1],\n" +
            "					[\"a2\", \"a2\", -1, 1, 0, -1],\n" +
            "					[\"b2\", \"b2\", 1, 0, 0, 1],\n" +
            "					[\"b2\", \"b2\", 0, 1, 0, -1],\n" +
            "					[\"b2\", \"b2\", -1, 1, 0, 1]\n" +
            "				]\n" +
            "			},\n" +
            "			\"tr\": {\n" +
            "				\"value\": 0.05,\n" +
            "				\"pair\": [\n" +
            "					[\"a2\", \"b1\", 0, 0, -0.8660254037844386, 0.5],\n" +
            "					[\"a1\", \"b2\", 0, 0, 0.8660254037844386, 0.5],\n" +
            "					[\"b2\", \"a1\", 1, 0, -0.8660254037844386, -0.5],\n" +
            "					[\"b1\", \"a2\", 1, 0, 0.8660254037844386, -0.5],\n" +
            "					[\"b2\", \"a1\", 0, 1, 0, 1],\n" +
            "					[\"b1\", \"a2\", 0, 1, 0, 1]\n" +
            "				]\n" +
            "			},\n" +
            "			\"tv\": {\n" +
            "				\"value\": 0.2,\n" +
            "				\"pair\": [\n" +
            "					[\"a1\", \"a1\", 0, 0, 0.5, 0],\n" +
            "					[\"b1\", \"b1\", 0, 0, -0.5, 0],\n" +
            "					[\"a2\", \"a2\", 0, 0, 0.5, 0],\n" +
            "					[\"b2\", \"b2\", 0, 0, -0.5, 0]\n" +
            "				]\n" +
            "			}\n" +
            "		}\n" +
            "	};\n" +
            "	function mul(a, b) {\n" +
            "		return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n" +
            "	}\n" +
            "	function add(a, b) {\n" +
            "		return [a[0] + b[0], a[1] + b[1]];\n" +
            "	}\n" +
            "	function sub(a, b) {\n" +
            "		return [a[0] - b[0], a[1] - b[1]];\n" +
            "	}\n" +
            "	function conj(a) {\n" +
            "		return [a[0], -a[1]];\n" +
            "	}\n" +
            "	function abs(a) {\n" +
            "		return Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n" +
            "	}\n" +
            "	function createArray(size, value) {\n" +
            "		var array = new Array(size);\n" +
            "		for (var i = 0; i < size; i++) {\n" +
            "			array[i] = value;\n" +
            "		}\n" +
            "		return array;\n" +
            "	}\n" +
            "	function getq(aii, ajj, aij) {\n" +
            "		var denom = aii[0] - ajj[0];\n" +
            "		var dir = [aij[0] / abs(aij), aij[1] / abs(aij)];\n" +
            "		if (Math.abs(denom) <= 1e-10) {\n" +
            "			return [Math.sqrt(0.5), [Math.sqrt(0.5) * dir[0], Math.sqrt(0.5) * dir[1]]];\n" +
            "		}\n" +
            "		else {\n" +
            "			var theta = 0.5 * Math.atan(2 * abs(aij) / denom);\n" +
            "			return [Math.cos(theta), [Math.sin(theta) * dir[0], Math.sin(theta) * dir[1]]];\n" +
            "		}\n" +
            "	}\n" +
            "	function qaq(Hij, q, theta, i, j, N) {\n" +
            "		var c = [theta[0], 0];\n" +
            "		var s = theta[1];\n" +
            "		for (var k = 0; k < N; k++) {\n" +
            "			var temp = add(mul(c, Hij[i * N + k]), mul(s, Hij[j * N + k]));\n" +
            "			Hij[j * N + k] = sub(mul(c, Hij[j * N + k]), mul(conj(s), Hij[i * N + k]));\n" +
            "			Hij[i * N + k] = temp;\n" +
            "			var temp = add(mul(c, q[k * N + i]), mul(conj(s), q[k * N + j]));\n" +
            "			q[k * N + j] = sub(mul(c, q[k * N + j]), mul(s, q[k * N + i]));\n" +
            "			q[k * N + i] = temp;\n" +
            "		}\n" +
            "		for (var k = 0; k < N; k++) {\n" +
            "			if (k != i && k != j) {\n" +
            "				Hij[k * N + j] = conj(Hij[j * N + k]);\n" +
            "				Hij[k * N + i] = conj(Hij[i * N + k]);\n" +
            "			}\n" +
            "			else {\n" +
            "				var temp = add(mul(c, Hij[k * N + i]), mul(conj(s), Hij[k * N + j]));\n" +
            "				Hij[k * N + j] = sub(mul(c, Hij[k * N + j]), mul(s, Hij[k * N + i]));\n" +
            "				Hij[k * N + i] = temp;\n" +
            "			}\n" +
            "		}\n" +
            "		return Hij;\n" +
            "	}\n" +
            "	function diag(x, N) {\n" +
            "		var e0 = 1;\n" +
            "		var psi;\n" +
            "		var q = createArray(N * N, [0, 0]);\n" +
            "		for (var i = 0; i < N; i++) {\n" +
            "			q[i * N + i] = [1, 0];\n" +
            "		}\n" +
            "		while (e0 > 1e-6) {\n" +
            "			var flag = 1;\n" +
            "			while (flag) {\n" +
            "				flag = 0;\n" +
            "				for (var i = 0; i < N; i++) {\n" +
            "					for (var j = i + 1; j < N; j++) {\n" +
            "						if (abs(x[i * N + j]) >= e0) {\n" +
            "							psi = getq(x[i * N + i], x[j * N + j], x[i * N + j]);\n" +
            "							x = qaq(x, q, psi, i, j, N);\n" +
            "							flag++;\n" +
            "						}\n" +
            "					}\n" +
            "				}\n" +
            "			}\n" +
            "			if (flag < N / 2) {\n" +
            "				e0 = e0 * 0.5;\n" +
            "			}\n" +
            "		}\n" +
            "		e0 = 1e-7;\n" +
            "		var flag = 1;\n" +
            "		while (flag) {\n" +
            "			flag = 0;\n" +
            "			for (var i = 0; i < N; i++) {\n" +
            "				for (var j = i + 1; j < N; j++) {\n" +
            "					if (abs(x[i * N + j]) >= e0) {\n" +
            "						psi = getq(x[i * N + i], x[j * N + j], x[i * N + j]);\n" +
            "						x = qaq(x, q, psi, i, j, N);\n" +
            "						flag++;\n" +
            "					}\n" +
            "				}\n" +
            "			}\n" +
            "		}\n" +
            "		var Ei = createArray(N, [0, 0]); // eigenvalues\n" +
            "		for (var _i2 = 0; _i2 < N; _i2++) {\n" +
            "			Ei[_i2] = {\n" +
            "				\"value\": x[_i2 * N + _i2][0],\n" +
            "				\"vector\": []\n" +
            "			};\n" +
            "			for (var i = 0; i < N; i++) {\n" +
            "				Ei[_i2].vector[i] = q[i * N + _i2];\n" +
            "			}\n" +
            "		}\n" +
            "		return Ei;\n" +
            "	}\n" +
            "	var atoms = {};\n" +
            "	var hoppings = [];\n" +
            "	for (var i = 0; i < conf.atom.length; i++) {\n" +
            "		atoms[conf.atom[i]] = i;\n" +
            "	}\n" +
            "	for (var i = 0; i < Object.values(conf.hopping).length; i++) {\n" +
            "		var value = Object.values(conf.hopping)[i].value;\n" +
            "		for (var j = 0; j < Object.values(conf.hopping)[i].pair.length; j++) {\n" +
            "			hoppings.push([\n" +
            "				atoms[Object.values(conf.hopping)[i].pair[j][0]],\n" +
            "				atoms[Object.values(conf.hopping)[i].pair[j][1]],\n" +
            "				Object.values(conf.hopping)[i].pair[j][2],\n" +
            "				Object.values(conf.hopping)[i].pair[j][3],\n" +
            "				mul([value, 0], [Object.values(conf.hopping)[i].pair[j][4], Object.values(conf.hopping)[i].pair[j][5]])\n" +
            "			]);\n" +
            "		}\n" +
            "	}\n" +
            "	function fgetv(u, v) {\n" +
            "		kx = u * 6.2832; ky = v * 6.2832;\n" +
            "		var hm = [];\n" +
            "		var eig = [];\n" +
            "		for (var i = 0; i < conf.atom.length; i++) {\n" +
            "			hm[i] = [];\n" +
            "			for (var j = 0; j < conf.atom.length; j++) {\n" +
            "				hm[i][j] = [0, 0];\n" +
            "			}\n" +
            "		}\n" +
            "		for (var j = 0; j < hoppings.length; j++) {\n" +
            "			var f = hoppings[j][0];\n" +
            "			var t = hoppings[j][1];\n" +
            "			var h = mul(hoppings[j][4], [Math.cos(kx * hoppings[j][2] + ky * hoppings[j][3]), -Math.sin(kx * hoppings[j][2] + ky * hoppings[j][3])]);\n" +
            "			hm[t][f] = add(hm[t][f], h);\n" +
            "			hm[f][t] = add(hm[f][t], conj(h));\n" +
            "		}\n" +
            "		var hm1 = [];\n" +
            "		for (var i = 0; i < conf.atom.length; i++) {\n" +
            "			for (var j = 0; j < conf.atom.length; j++) {\n" +
            "				hm1[i * conf.atom.length + j] = hm[i][j];\n" +
            "			}\n" +
            "		}\n" +
            "		eig = diag(hm1, conf.atom.length).sort((a, b) => a.value - b.value);\n" +
            "		pf = [0, 0];\n" +
            "		pf = add(pf, mul(conj(eig[0].vector[0]), conj(eig[1].vector[1])));\n" +
            "		pf = sub(pf, mul(conj(eig[0].vector[1]), conj(eig[1].vector[0])));\n" +
            "		pf = add(pf, mul(conj(eig[0].vector[2]), conj(eig[1].vector[3])));\n" +
            "		pf = sub(pf, mul(conj(eig[0].vector[3]), conj(eig[1].vector[2])));\n" +
            "		return {\n" +
            "			\"x\": kx * Math.sqrt(0.75),\n" +
            "			\"z\": ky - 0.5 * kx,\n" +
            "			\"y\": Math.sqrt(pf[0] * pf[0] + pf[1] * pf[1]) * 2\n" +
            "		};\n" +
            "	}\n" +
            "	return fgetv;\n" +
            "})();\n" +
            "MapSize = 32768;\n" +
            "noqi = 16;\n" +
            "Noq = 2048;\n" +
            "coslim = 1.0 - 1.0 / 16;\n" +
            "aculim = 0.002;\n" +
            "clear();\n";

        cos = Math.cos;
        sin = Math.sin;
        sqrt = Math.sqrt;
        max = Math.max;
        min = Math.min;
        abs = Math.abs;

        Array.prototype.push3 = function (v) {
            this.push(v.x);
            this.push(v.y);
            this.push(v.z);
        }
        var vertexs = [], colors = [], normals = [];

        function convertolinear(a) {
            var b = [];
            for (var i = 0; i < a.length; i++) {
                b.push(a[i].x);
                b.push(a[i].y);
                b.push(a[i].z);
            }
            return b;
        }

        function ontimer() {
            draw();
            window.requestAnimationFrame(ontimer);
        }

        function sep() {
            var i, j;
            for (i = 0; i < 4; i++) {
                quaMap[i] = 0;
            }
            for (i = 0; i < noqi; i++) {
                for (j = 0; j < noqi; j++) {
                    quaMap[i + j * noqi + 4] = 0;
                    Mapbot[i + j * noqi + 4] = (i + (j + noqi - 1) % noqi * noqi) + 4;
                    Maprig[i + j * noqi + 4] = ((i + 1) % noqi + j * noqi) + 4;
                    Maptop[i + j * noqi + 4] = (i + (j + 1) % noqi * noqi) + 4;
                    Maplef[i + j * noqi + 4] = ((i + noqi - 1) % noqi + j * noqi) + 4;
                    qual[i + j * noqi + 4] = 1.0 / noqi;
                    quau[i + j * noqi + 4] = 1.0 * i / noqi - 0.0;
                    quav[i + j * noqi + 4] = 1.0 * j / noqi - 0.0;
                }
            }
            end = noqi * noqi + 4;
            for (i = 4; i < end; i++) {
                sepaquad(i, 0);
            }
        }
        function sepaquad(cur, force) {
            var u, v, l;
            u = quau[cur];
            v = quav[cur];
            l = qual[cur];
            if (l < (1.4 / Noq)) {
                return;
            }
            if (end > MapSize - 4) {
                return;
            }
            if (force | needsep(u, v, l)) {
                if (Mapbot[cur] < 4) {
                    sepaquad(Mapbot[Mapfat[cur]], 1);
                }
                if (Maprig[cur] < 4) {
                    sepaquad(Maprig[Mapfat[cur]], 1);
                }
                if (Maptop[cur] < 4) {
                    sepaquad(Maptop[Mapfat[cur]], 1);
                }
                if (Maplef[cur] < 4) {
                    sepaquad(Maplef[Mapfat[cur]], 1);
                }
                if (end > MapSize - 4) {
                    return;
                }
                quaMap[cur] = end;
                end += 4;

                quaMap[quaMap[cur] + 0] = 0;
                quaMap[quaMap[cur] + 1] = 0;
                quaMap[quaMap[cur] + 2] = 0;
                quaMap[quaMap[cur] + 3] = 0;

                Mapfat[quaMap[cur] + 0] = cur;
                Mapfat[quaMap[cur] + 1] = cur;
                Mapfat[quaMap[cur] + 2] = cur;
                Mapfat[quaMap[cur] + 3] = cur;

                qual[quaMap[cur] + 0] = l / 2;
                qual[quaMap[cur] + 1] = l / 2;
                qual[quaMap[cur] + 2] = l / 2;
                qual[quaMap[cur] + 3] = l / 2;

                quau[quaMap[cur] + 0] = u;
                quau[quaMap[cur] + 1] = u + l / 2;
                quau[quaMap[cur] + 2] = u;
                quau[quaMap[cur] + 3] = u + l / 2;

                quav[quaMap[cur] + 0] = v;
                quav[quaMap[cur] + 1] = v;
                quav[quaMap[cur] + 2] = v + l / 2;
                quav[quaMap[cur] + 3] = v + l / 2;

                Mapbot[quaMap[cur] + 0] = quaMap[Mapbot[cur]] + 2;
                Mapbot[quaMap[cur] + 1] = quaMap[Mapbot[cur]] + 3;
                Mapbot[quaMap[cur] + 2] = quaMap[cur] + 0;
                Mapbot[quaMap[cur] + 3] = quaMap[cur] + 1;
                if (quaMap[Mapbot[cur]]) {
                    Maptop[quaMap[Mapbot[cur]] + 2] = quaMap[cur] + 0;
                    Maptop[quaMap[Mapbot[cur]] + 3] = quaMap[cur] + 1;
                }

                Maprig[quaMap[cur] + 0] = quaMap[cur] + 1;
                Maprig[quaMap[cur] + 1] = quaMap[Maprig[cur]] + 0;
                Maprig[quaMap[cur] + 2] = quaMap[cur] + 3;
                Maprig[quaMap[cur] + 3] = quaMap[Maprig[cur]] + 2;
                if (quaMap[Maprig[cur]]) {
                    Maplef[quaMap[Maprig[cur]] + 0] = quaMap[cur] + 1;
                    Maplef[quaMap[Maprig[cur]] + 2] = quaMap[cur] + 3;
                }

                Maptop[quaMap[cur] + 0] = quaMap[cur] + 2;
                Maptop[quaMap[cur] + 1] = quaMap[cur] + 3;
                Maptop[quaMap[cur] + 2] = quaMap[Maptop[cur]] + 0;
                Maptop[quaMap[cur] + 3] = quaMap[Maptop[cur]] + 1;
                if (quaMap[Maptop[cur]]) {
                    Mapbot[quaMap[Maptop[cur]] + 0] = quaMap[cur] + 2;
                    Mapbot[quaMap[Maptop[cur]] + 1] = quaMap[cur] + 3;
                }

                Maplef[quaMap[cur] + 0] = quaMap[Maplef[cur]] + 1;
                Maplef[quaMap[cur] + 1] = quaMap[cur] + 0;
                Maplef[quaMap[cur] + 2] = quaMap[Maplef[cur]] + 3;
                Maplef[quaMap[cur] + 3] = quaMap[cur] + 2;
                if (quaMap[Maplef[cur]]) {
                    Maprig[quaMap[Maplef[cur]] + 1] = quaMap[cur] + 0;
                    Maprig[quaMap[Maplef[cur]] + 3] = quaMap[cur] + 2;
                }
            }
        }

        function distanceofline(a, b, c) {
            return abs(dot(cross(a, b), c) / sqrt(norm(cross(sub(a, b), c))));
        }

        function needsep(u, v, l) {
            var vertex = Array(6), normal = Array(5), vector = Array(6);
            var sca = Array(4), a, b, c, d, cosx = Array(4);
            var i, invalidcount;
            var disofl = 0.0;

            invalidcount = 0;
            vertex[0] = getv(u, v);
            vertex[1] = getv(u + l, v);
            vertex[2] = getv(u + l, v + l);
            vertex[3] = getv(u, v + l);
            vertex[4] = getv(u + l / 2, v + l / 2);
            for (i = 0; i < 5; i++) {
                if (invalid(vertex[i])) {
                    invalidcount++;
                }
            }
            if (invalidcount == 5) {
                return 0;
            }
            if (invalidcount) {
                return 1;
            }
            for (i = 0; i < 4; i++) {
                vector[i] = sub(vertex[i], vertex[4]);
            }
            for (i = 0; i < 2; i++) {
                disofl = max(disofl, distanceofline(vector[i], vector[i + 2], vector[i + 1]));
            }
            disofl = max(disofl, distanceofline(vector[2], vector[0], vector[3]));
            disofl = max(disofl, distanceofline(vector[3], vector[1], vector[0]));
            normal[0] = cross(vector[0], vector[1]);
            normal[1] = cross(vector[1], vector[2]);
            normal[2] = cross(vector[2], vector[3]);
            normal[3] = cross(vector[3], vector[0]);
            for (i = 0; i < 4; i++) {
                sca[i] = sqrt(norm(normal[i]));
            }
            for (i = 1; i < 4; i++) {
                cosx[i] = dot(normal[i], normal[i - 1]) / (sca[i] * sca[i - 1]);
            }
            cosx[0] = dot(normal[0], normal[3]) / (sca[0] * sca[3]);
            a = min(cosx[0], cosx[1]);
            b = min(cosx[2], cosx[3]);
            d = min(a, b);
            if (d < coslim || disofl > aculim) {
                return 1;
            }
            if ((v - 0.5 * l) > 0) {
                vertex[5] = getv(u + l / 2, v - l * 0.5);
                vector[4] = sub(vertex[0], vertex[5]);
                vector[5] = sub(vertex[1], vertex[5]);
                normal[4] = cross(vector[5], vector[4]);
                a = dot(normal[0], normal[4]) / (sca[0] * sqrt(norm(normal[4])));
                d = min(d, a);
                disofl = max(disofl, distanceofline(vector[5], vector[4], sub(vertex[4], vertex[5])));
            }
            if ((u + 1.5 * l) < 1) {
                vertex[5] = getv(u + l * 1.5, v + l * 0.5);
                vector[4] = sub(vertex[1], vertex[5]);
                vector[5] = sub(vertex[2], vertex[5]);
                normal[4] = cross(vector[5], vector[4]);
                a = dot(normal[1], normal[4]) / (sca[1] * sqrt(norm(normal[4])));
                d = min(d, a);
                disofl = max(disofl, distanceofline(vector[5], vector[4], sub(vertex[4], vertex[5])));
            }
            if ((v + 1.5 * l) < 1) {
                vertex[5] = getv(u + l * 0.5, v + l * 1.5);
                vector[4] = sub(vertex[2], vertex[5]);
                vector[5] = sub(vertex[3], vertex[5]);
                normal[4] = cross(vector[5], vector[4]);
                a = dot(normal[2], normal[4]) / (sca[2] * sqrt(norm(normal[4])));
                d = min(d, a);
                disofl = max(disofl, distanceofline(vector[5], vector[4], sub(vertex[4], vertex[5])));
            }
            if ((u - 0.5 * l) > 0) {
                vertex[5] = getv(u - l * 0.5, v + l * 0.5);
                vector[4] = sub(vertex[3], vertex[5]);
                vector[5] = sub(vertex[0], vertex[5]);
                normal[4] = cross(vector[5], vector[4]);
                a = dot(normal[3], normal[4]) / (sca[3] * sqrt(norm(normal[4])));
                d = min(d, a);
                disofl = max(disofl, distanceofline(vector[5], vector[4], sub(vertex[4], vertex[5])));
            }
            if (d < coslim || disofl > aculim) {
                return 1;
            }
            return 0;
        }

        getv = (function () {
            conf = {
                "repeat": 30,
                "kpoint": 256,
                "atom": ["a1", "a2", "b1", "b2"],
                "hopping": {
                    "t": {
                        "value": 1,
                        "pair": [
                            ["a1", "b1", 0, 0, 1, 0],
                            ["b1", "a1", 1, 0, 1, 0],
                            ["b1", "a1", 0, 1, 1, 0],
                            ["a2", "b2", 0, 0, 1, 0],
                            ["b2", "a2", 1, 0, 1, 0],
                            ["b2", "a2", 0, 1, 1, 0]
                        ]
                    },
                    "tso": {
                        "value": 0.06,
                        "pair": [
                            ["a1", "a1", 1, 0, 0, 1],
                            ["a1", "a1", 0, 1, 0, -1],
                            ["a1", "a1", -1, 1, 0, 1],
                            ["b1", "b1", 1, 0, 0, -1],
                            ["b1", "b1", 0, 1, 0, 1],
                            ["b1", "b1", -1, 1, 0, -1],
                            ["a2", "a2", 1, 0, 0, -1],
                            ["a2", "a2", 0, 1, 0, 1],
                            ["a2", "a2", -1, 1, 0, -1],
                            ["b2", "b2", 1, 0, 0, 1],
                            ["b2", "b2", 0, 1, 0, -1],
                            ["b2", "b2", -1, 1, 0, 1]
                        ]
                    },
                    "tr": {
                        "value": 0.05,
                        "pair": [
                            ["a2", "b1", 0, 0, -0.8660254037844386, 0.5],
                            ["a1", "b2", 0, 0, 0.8660254037844386, 0.5],
                            ["b2", "a1", 1, 0, -0.8660254037844386, -0.5],
                            ["b1", "a2", 1, 0, 0.8660254037844386, -0.5],
                            ["b2", "a1", 0, 1, 0, 1],
                            ["b1", "a2", 0, 1, 0, 1]
                        ]
                    },
                    "tv": {
                        "value": 0.2,
                        "pair": [
                            ["a1", "a1", 0, 0, 0.5, 0],
                            ["b1", "b1", 0, 0, -0.5, 0],
                            ["a2", "a2", 0, 0, 0.5, 0],
                            ["b2", "b2", 0, 0, -0.5, 0]
                        ]
                    }
                }
            };

            function mul(a, b) {
                return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
            }
            function add(a, b) {
                return [a[0] + b[0], a[1] + b[1]];
            }
            function sub(a, b) {
                return [a[0] - b[0], a[1] - b[1]];
            }
            function conj(a) {
                return [a[0], -a[1]];
            }
            function abs(a) {
                return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
            }
            function createArray(size, value) {
                var array = new Array(size);
                for (var i = 0; i < size; i++) {
                    array[i] = value;
                }
                return array;
            }

            function getq(aii, ajj, aij) {
                var denom = aii[0] - ajj[0];
                var dir = [aij[0] / abs(aij), aij[1] / abs(aij)];
                if (Math.abs(denom) <= 1e-10) {
                    return [Math.sqrt(0.5), [Math.sqrt(0.5) * dir[0], Math.sqrt(0.5) * dir[1]]];
                }
                else {
                    var theta = 0.5 * Math.atan(2 * abs(aij) / denom);
                    return [Math.cos(theta), [Math.sin(theta) * dir[0], Math.sin(theta) * dir[1]]];
                }
            }

            function qaq(Hij, q, theta, i, j, N) {
                var c = [theta[0], 0];
                var s = theta[1];
                for (var k = 0; k < N; k++) {
                    var temp = add(mul(c, Hij[i * N + k]), mul(s, Hij[j * N + k]));
                    Hij[j * N + k] = sub(mul(c, Hij[j * N + k]), mul(conj(s), Hij[i * N + k]));
                    Hij[i * N + k] = temp;

                    var temp = add(mul(c, q[k * N + i]), mul(conj(s), q[k * N + j]));
                    q[k * N + j] = sub(mul(c, q[k * N + j]), mul(s, q[k * N + i]));
                    q[k * N + i] = temp;
                }

                for (var k = 0; k < N; k++) {
                    if (k != i && k != j) {
                        Hij[k * N + j] = conj(Hij[j * N + k]);
                        Hij[k * N + i] = conj(Hij[i * N + k]);
                    }
                    else {
                        var temp = add(mul(c, Hij[k * N + i]), mul(conj(s), Hij[k * N + j]));
                        Hij[k * N + j] = sub(mul(c, Hij[k * N + j]), mul(s, Hij[k * N + i]));
                        Hij[k * N + i] = temp;
                    }
                }
                return Hij;
            }

            function diag(x, N) {
                var e0 = 1;
                var psi;
                var q = createArray(N * N, [0, 0]);
                for (var i = 0; i < N; i++) {
                    q[i * N + i] = [1, 0];
                }

                while (e0 > 1e-6) {
                    var flag = 1;
                    while (flag) {
                        flag = 0;
                        for (var i = 0; i < N; i++) {
                            for (var j = i + 1; j < N; j++) {
                                if (abs(x[i * N + j]) >= e0) {
                                    psi = getq(x[i * N + i], x[j * N + j], x[i * N + j]);
                                    x = qaq(x, q, psi, i, j, N);
                                    flag++;
                                }
                            }
                        }
                    }
                    if (flag < N / 2) {
                        e0 = e0 * 0.5;
                    }
                }
                e0 = 1e-7;
                var flag = 1;
                while (flag) {
                    flag = 0;
                    for (var i = 0; i < N; i++) {
                        for (var j = i + 1; j < N; j++) {
                            if (abs(x[i * N + j]) >= e0) {
                                psi = getq(x[i * N + i], x[j * N + j], x[i * N + j]);
                                x = qaq(x, q, psi, i, j, N);
                                flag++;
                            }
                        }
                    }
                }

                var Ei = createArray(N, [0, 0]); // eigenvalues


                for (var _i2 = 0; _i2 < N; _i2++) {
                    Ei[_i2] = {
                        "value": x[_i2 * N + _i2][0],
                        "vector": []
                    };
                    for (var i = 0; i < N; i++) {
                        Ei[_i2].vector[i] = q[i * N + _i2];
                    }
                }
                return Ei;
            }

            var atoms = {};
            var hoppings = [];
            for (var i = 0; i < conf.atom.length; i++) {
                atoms[conf.atom[i]] = i;
            }
            for (var i = 0; i < Object.values(conf.hopping).length; i++) {
                var value = Object.values(conf.hopping)[i].value;
                for (var j = 0; j < Object.values(conf.hopping)[i].pair.length; j++) {
                    hoppings.push([
                        atoms[Object.values(conf.hopping)[i].pair[j][0]],
                        atoms[Object.values(conf.hopping)[i].pair[j][1]],
                        Object.values(conf.hopping)[i].pair[j][2],
                        Object.values(conf.hopping)[i].pair[j][3],
                        mul([value, 0], [Object.values(conf.hopping)[i].pair[j][4], Object.values(conf.hopping)[i].pair[j][5]])
                    ]);
                }
            }

            function fgetv(u, v) {

                kx = u * 6.2832; ky = v * 6.2832;

                var hm = [];
                var eig = [];
                for (var i = 0; i < conf.atom.length; i++) {
                    hm[i] = [];
                    for (var j = 0; j < conf.atom.length; j++) {
                        hm[i][j] = [0, 0];
                    }
                }
                for (var j = 0; j < hoppings.length; j++) {
                    var f = hoppings[j][0];
                    var t = hoppings[j][1];
                    var h = mul(hoppings[j][4], [Math.cos(kx * hoppings[j][2] + ky * hoppings[j][3]), -Math.sin(kx * hoppings[j][2] + ky * hoppings[j][3])]);
                    hm[t][f] = add(hm[t][f], h);
                    hm[f][t] = add(hm[f][t], conj(h));
                }
                var hm1 = [];
                for (var i = 0; i < conf.atom.length; i++) {
                    for (var j = 0; j < conf.atom.length; j++) {
                        hm1[i * conf.atom.length + j] = hm[i][j];
                    }
                }
                eig = diag(hm1, conf.atom.length).sort((a, b) => a.value - b.value);
                pf = [0, 0];
                pf = add(pf, mul(conj(eig[0].vector[0]), conj(eig[1].vector[1])));
                pf = sub(pf, mul(conj(eig[0].vector[1]), conj(eig[1].vector[0])));
                pf = add(pf, mul(conj(eig[0].vector[2]), conj(eig[1].vector[3])));
                pf = sub(pf, mul(conj(eig[0].vector[3]), conj(eig[1].vector[2])));
                return {
                    "x": kx * Math.sqrt(0.75),
                    "z": ky - 0.5 * kx,
                    "y": Math.sqrt(pf[0] * pf[0] + pf[1] * pf[1]) * 2
                };
            }
            return fgetv;
        })();

        function invalid(vertex) {
            if (!isFinite(vertex.x)) {
                return 1;
            }
            if (!isFinite(vertex.y)) {
                return 1;
            }
            if (!isFinite(vertex.z)) {
                return 1;
            }
            return 0;
        }
        function norm(x1) {
            return x1.x * x1.x + x1.y * x1.y + x1.z * x1.z;
        }
        function cross(x1, x2) {
            return { "x": x1.y * x2.z - x1.z * x2.y, "y": x1.z * x2.x - x1.x * x2.z, "z": x1.x * x2.y - x1.y * x2.x };
        }
        function dot(x1, x2) {
            return x1.x * x2.x + x1.y * x2.y + x1.z * x2.z;
        }

        function scan() {

            vertexs.length = 0;
            normals.length = 0;
            colors.length = 0;

            var i;
            var u, v, l;
            var vertex = Array(5), normal = Array(5);
            var c = Array(5);
            for (i = 4; i < end; i++) {
                if (quaMap[i] == 0) {
                    u = quau[i];
                    v = quav[i];
                    l = qual[i];
                    vertex[0] = getv(u, v);
                    vertex[1] = getv(u + l, v);
                    vertex[2] = getv(u + l, v + l);
                    vertex[3] = getv(u, v + l);
                    vertex[4] = getv(u + l / 2, v + l / 2);
                    if (!invalid(vertex[0])) {
                        normal[0] = getn(u, v, l);
                    }
                    if (!invalid(vertex[1])) {
                        normal[1] = getn(u + l, v, l);
                    }
                    if (!invalid(vertex[2])) {
                        normal[2] = getn(u + l, v + l, l);
                    }
                    if (!invalid(vertex[3])) {
                        normal[3] = getn(u, v + l, l);
                    }
                    if (!invalid(vertex[4])) {
                        normal[4] = getn(u + l / 2, v + l / 2, l);
                    }

                    c[0] = { "x": u, "y": v };
                    c[1] = { "x": u + l, "y": v };
                    c[2] = { "x": u + l, "y": v + l };
                    c[3] = { "x": u, "y": v + l };
                    c[4] = { "x": u + l / 2, "y": v + l / 2 };

                    if (quaMap[Mapbot[i]]) {
                        tri2(vertexs, colors, normals, vertex[0], vertex[1], vertex[4], normal[0], normal[1], normal[4], c[0], c[1], c[4], l);
                    }
                    else {
                        tri1(vertexs, colors, normals, vertex[0], vertex[1], vertex[4], normal[0], normal[1], normal[4], c[0], c[1], c[4], l);
                    }
                    if (quaMap[Maprig[i]]) {
                        tri2(vertexs, colors, normals, vertex[1], vertex[2], vertex[4], normal[1], normal[2], normal[4], c[1], c[2], c[4], l);
                    }
                    else {
                        tri1(vertexs, colors, normals, vertex[1], vertex[2], vertex[4], normal[1], normal[2], normal[4], c[1], c[2], c[4], l);
                    }
                    if (quaMap[Maptop[i]]) {
                        tri2(vertexs, colors, normals, vertex[2], vertex[3], vertex[4], normal[2], normal[3], normal[4], c[2], c[3], c[4], l);
                    }
                    else {
                        tri1(vertexs, colors, normals, vertex[2], vertex[3], vertex[4], normal[2], normal[3], normal[4], c[2], c[3], c[4], l);
                    }
                    if (quaMap[Maplef[i]]) {
                        tri2(vertexs, colors, normals, vertex[3], vertex[0], vertex[4], normal[3], normal[0], normal[4], c[3], c[0], c[4], l);
                    }
                    else {
                        tri1(vertexs, colors, normals, vertex[3], vertex[0], vertex[4], normal[3], normal[0], normal[4], c[3], c[0], c[4], l);
                    }
                }
                if (vertexs.length > 1048576 * 16) {
                    pushv();
                }
            }
            pushv();
        }

        function pushv() {
            if (vertexs.length > 2) {
                vbuffer.push(gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer[vbuffer.length - 1]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexs), gl.STATIC_DRAW);

                nbuffer.push(gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, nbuffer[nbuffer.length - 1]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

                cbuffer.push(gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, cbuffer[cbuffer.length - 1]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

                points.push(vertexs.length / 3);
            }
            vertexs.length = 0;
            normals.length = 0;
            colors.length = 0;

        }

        function tri1(vertexs, colors, normals, v1, v2, v3, n1, n2, n3, c1, c2, c3, l) {
            var inv = Array(3), invcount;
            inv[0] = invalid(v1);
            inv[1] = invalid(v2);
            inv[2] = invalid(v3);
            invcount = inv[0] + inv[1] + inv[2];
            switch (invcount) {
                case 0: {
                    vertexs.push3(v1);
                    vertexs.push3(v2);
                    vertexs.push3(v3);
                    normals.push3(n1);
                    normals.push3(n2);
                    normals.push3(n3);
                    colors.push3(getc(c1.x, c1.y));
                    colors.push3(getc(c2.x, c2.y));
                    colors.push3(getc(c3.x, c3.y));
                    break;
                }
                case 1: {
                    if (inv[0]) {
                        invtri1(vertexs, colors, normals, v2, v3, n2, n3, c2, c3, c1, l);
                    }
                    if (inv[1]) {
                        invtri1(vertexs, colors, normals, v3, v1, n3, n1, c3, c1, c2, l);
                    }
                    if (inv[2]) {
                        invtri1(vertexs, colors, normals, v1, v2, n1, n2, c1, c2, c3, l);
                    }
                    break;
                }
                case 2: {
                    if (!inv[0]) {
                        invtri2(vertexs, colors, normals, v1, n1, c1, c2, c3, l);
                    }
                    if (!inv[1]) {
                        invtri2(vertexs, colors, normals, v2, n2, c2, c3, c1, l);
                    }
                    if (!inv[2]) {
                        invtri2(vertexs, colors, normals, v3, n3, c3, c1, c2, l);
                    }
                    break;
                }
            }
        }

        function tri2(vertexs, colors, normals, v1, v2, v3, n1, n2, n3, c1, c2, c3, l) {
            var v4, n4;
            var c4;
            var inv = Array(4), invcountl, invcountr;
            c4 = { "x": (c1.x + c2.x) / 2, "y": (c1.y + c2.y) / 2 };
            v4 = getv(c4.x, c4.y);
            inv[0] = invalid(v1);
            inv[1] = invalid(v2);
            inv[2] = invalid(v3);
            inv[3] = invalid(v4);
            if (!inv[3]) {
                n4 = getn(c4.x, c4.y, l);
            }
            invcountl = inv[0] + inv[3] + inv[2];
            invcountr = inv[3] + inv[1] + inv[2];
            switch (invcountl) {
                case 0: {
                    vertexs.push3(v1);
                    vertexs.push3(v4);
                    vertexs.push3(v3);
                    normals.push3(n1);
                    normals.push3(n4);
                    normals.push3(n3);
                    colors.push3(getc(c1.x, c1.y));
                    colors.push3(getc((c1.x + c2.x) / 2, (c1.y + c2.y) / 2));
                    colors.push3(getc(c3.x, c3.y));
                    break;
                }
                case 1: {
                    if (inv[0]) {
                        invtri1(vertexs, colors, normals, v4, v3, n4, n3, c4, c3, c1, l);
                    }
                    if (inv[3]) {
                        invtri1(vertexs, colors, normals, v3, v1, n3, n1, c3, c1, c4, l);
                    }
                    if (inv[2]) {
                        invtri1(vertexs, colors, normals, v1, v4, n1, n4, c1, c4, c3, l);
                    }
                    break;
                }
                case 2: {
                    if (!inv[0]) {
                        invtri2(vertexs, colors, normals, v1, n1, c1, c4, c3, l);
                    }
                    if (!inv[3]) {
                        invtri2(vertexs, colors, normals, v4, n4, c4, c3, c1, l);
                    }
                    if (!inv[2]) {
                        invtri2(vertexs, colors, normals, v3, n3, c3, c1, c4, l);
                    }
                    break;
                }
            }
            switch (invcountr) {
                case 0: {
                    vertexs.push3(v4);
                    vertexs.push3(v2);
                    vertexs.push3(v3);
                    normals.push3(n4);
                    normals.push3(n2);
                    normals.push3(n3);
                    colors.push3(getc((c1.x + c2.x) / 2, (c1.y + c2.y) / 2));
                    colors.push3(getc(c2.x, c2.y));
                    colors.push3(getc(c3.x, c3.y));
                    break;
                }
                case 1: {
                    if (inv[3]) {
                        invtri1(vertexs, colors, normals, v2, v3, n2, n3, c2, c3, c4, l);
                    }
                    if (inv[1]) {
                        invtri1(vertexs, colors, normals, v3, v4, n3, n4, c3, c4, c2, l);
                    }
                    if (inv[2]) {
                        invtri1(vertexs, colors, normals, v4, v2, n4, n2, c4, c2, c3, l);
                    }
                    break;
                }
                case 2: {
                    if (!inv[3]) {
                        invtri2(vertexs, colors, normals, v4, n4, c4, c2, c3, l);
                    }
                    if (!inv[1]) {
                        invtri2(vertexs, colors, normals, v2, n2, c2, c3, c4, l);
                    }
                    if (!inv[2]) {
                        invtri2(vertexs, colors, normals, v3, n3, c3, c4, c2, l);
                    }
                    break;
                }
            }
        }

        function double2() {
            this.x = 0.0;
            this.y = 0.0;
        }

        function invtri1(vertexs, colors, normals, v1, v2, n1, n2, c1, c2, c3, l) {
            var left, right, mid;
            var c4 = new double2(), c5 = new double2();
            var v4, v5, n4, n5;
            left = 0;
            right = 1;
            while ((right - left) > (1.0e-6)) {
                mid = (left + right) / 2;
                c4.x = c3.x * mid + c1.x * (1.0 - mid);
                c4.y = c3.y * mid + c1.y * (1.0 - mid);
                v4 = getv(c4.x, c4.y);
                if (invalid(v4)) {
                    right = mid;
                }
                else {
                    left = mid;
                }
            }
            c4.x = c3.x * left + c1.x * (1.0 - left);
            c4.y = c3.y * left + c1.y * (1.0 - left);

            left = 0;
            right = 1;
            while ((right - left) > (1.0e-6)) {
                mid = (left + right) / 2;
                c5.x = c3.x * mid + c2.x * (1.0 - mid);
                c5.y = c3.y * mid + c2.y * (1.0 - mid);
                v5 = getv(c5.x, c5.y);
                if (invalid(v5)) {
                    right = mid;
                }
                else {
                    left = mid;
                }
            }
            c5.x = c3.x * left + c2.x * (1.0 - left);
            c5.y = c3.y * left + c2.y * (1.0 - left);

            v4 = getv(c4.x, c4.y);
            n4 = getn(c4.x, c4.y, l);
            v5 = getv(c5.x, c5.y);
            n5 = getn(c5.x, c5.y, l);
            vertexs.push3(v1);
            vertexs.push3(v2);
            vertexs.push3(v5);
            normals.push3(n1);
            normals.push3(n2);
            normals.push3(n5);
            colors.push3(getc(c1.x, c1.y));
            colors.push3(getc(c2.x, c2.y));
            colors.push3(getc(c5.x, c5.y));
            vertexs.push3(v1);
            vertexs.push3(v5);
            vertexs.push3(v4);
            normals.push3(n1);
            normals.push3(n5);
            normals.push3(n4);
            colors.push3(getc(c1.x, c1.y));
            colors.push3(getc(c5.x, c5.y));
            colors.push3(getc(c4.x, c4.y));
        }

        function invtri2(vertexs, colors, normals, v1, n1, c1, c2, c3, l) {
            var left, right, mid;
            var c4 = new double2(), c5 = new double2();
            var v4, v5, n4, n5;
            left = 0;
            right = 1;
            while ((right - left) > (1.0e-6)) {
                mid = (left + right) / 2;
                c4.x = c2.x * mid + c1.x * (1.0 - mid);
                c4.y = c2.y * mid + c1.y * (1.0 - mid);
                v4 = getv(c4.x, c4.y);
                if (invalid(v4)) {
                    right = mid;
                }
                else {
                    left = mid;
                }
            }
            c4.x = c2.x * left + c1.x * (1.0 - left);
            c4.y = c2.y * left + c1.y * (1.0 - left);

            left = 0;
            right = 1;
            while ((right - left) > (1.0e-6)) {
                mid = (left + right) / 2;
                c5.x = c3.x * mid + c1.x * (1.0 - mid);
                c5.y = c3.y * mid + c1.y * (1.0 - mid);
                v5 = getv(c5.x, c5.y);
                if (invalid(v5)) {
                    right = mid;
                }
                else {
                    left = mid;
                }
            }
            c5.x = c3.x * left + c1.x * (1.0 - left);
            c5.y = c3.y * left + c1.y * (1.0 - left);

            v4 = getv(c4.x, c4.y);
            n4 = getn(c4.x, c4.y, l);
            v5 = getv(c5.x, c5.y);
            n5 = getn(c5.x, c5.y, l);
            vertexs.push3(v1);
            vertexs.push3(v4);
            vertexs.push3(v5);
            normals.push3(n1);
            normals.push3(n4);
            normals.push3(n5);
            colors.push3(getc(c1.x, c1.y));
            colors.push3(getc(c4.x, c4.y));
            colors.push3(getc(c5.x, c5.y));
        }

        function sub(x, y) {
            return { "x": x.x - y.x, "y": x.y - y.y, "z": x.z - y.z };
        }

        function getn(u, v, l) {
            var abnor, ltemp, ltemp1, x0;
            var vec = Array(2), nor;
            var i, isnan;
            ltemp = l / 16;
            vec[0] = sub(getv(u + ltemp, v), getv(u - ltemp, v));
            vec[1] = sub(getv(u, v + ltemp), getv(u, v - ltemp));
            if (!invalid(vec[0]) && !invalid(vec[1])) {
                ltemp /= 4;
                vec[0] = sub(getv(u + ltemp, v), getv(u - ltemp, v));
                vec[1] = sub(getv(u, v + ltemp), getv(u, v - ltemp));
                nor = cross(vec[0], vec[1]);
                var odbl = 1.0 / sqrt(norm(nor));
                return { "x": nor.x * odbl, "y": nor.y * odbl, "z": nor.z * odbl };
            }
            else {
                ltemp = l / 8;
                while (ltemp > l * 1.0e-4) {
                    var dl = [0.9659, 0.2588, 0.2588, 0.9659];
                    var dlt;

                    vec[0] = getv(u + ltemp, v);
                    vec[1] = getv(u, v + ltemp);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }
                    for (i = 0; i < 2; i++) {
                        dlt = 0.5 * dl[i * 2] - 0.86603 * dl[i * 2 + 1];
                        dl[i * 2 + 1] = 0.5 * dl[i * 2 + 1] + 0.86603 * dl[i * 2];
                        dl[i * 2] = dlt;
                    }

                    vec[0] = getv(u + ltemp * 0.5, v + ltemp * 0.866);
                    vec[1] = getv(u - ltemp * 0.866, v + ltemp * 0.5);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }
                    for (i = 0; i < 2; i++) {
                        dlt = 0.5 * dl[i * 2] - 0.86603 * dl[i * 2 + 1];
                        dl[i * 2 + 1] = 0.5 * dl[i * 2 + 1] + 0.86603 * dl[i * 2];
                        dl[i * 2] = dlt;
                    }

                    vec[0] = getv(u - ltemp * 0.5, v + ltemp * 0.866);
                    vec[1] = getv(u - ltemp * 0.866, v - ltemp * 0.5);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }
                    for (i = 0; i < 2; i++) {
                        dlt = 0.5 * dl[i * 2] - 0.86603 * dl[i * 2 + 1];
                        dl[i * 2 + 1] = 0.5 * dl[i * 2 + 1] + 0.86603 * dl[i * 2];
                        dl[i * 2] = dlt;
                    }

                    vec[0] = getv(u - ltemp, v);
                    vec[1] = getv(u, v - ltemp);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }
                    for (i = 0; i < 2; i++) {
                        dlt = 0.5 * dl[i * 2] - 0.86603 * dl[i * 2 + 1];
                        dl[i * 2 + 1] = 0.5 * dl[i * 2 + 1] + 0.86603 * dl[i * 2];
                        dl[i * 2] = dlt;
                    }

                    vec[0] = getv(u - ltemp * 0.5, v - ltemp * 0.866);
                    vec[1] = getv(u + ltemp * 0.866, v - ltemp * 0.5);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }
                    for (i = 0; i < 2; i++) {
                        dlt = 0.5 * dl[i * 2] - 0.86603 * dl[i * 2 + 1];
                        dl[i * 2 + 1] = 0.5 * dl[i * 2 + 1] + 0.86603 * dl[i * 2];
                        dl[i * 2] = dlt;
                    }

                    vec[0] = getv(u + ltemp * 0.5, v - ltemp * 0.866);
                    vec[1] = getv(u + ltemp * 0.866, v + ltemp * 0.5);
                    if (!invalid(vec[0]) && !invalid(vec[1])) {
                        return getn1(u, v, ltemp / 2, dl);
                    }

                    ltemp /= 2;
                }
                return { "x": 1.0, "y": 0.0, "z": 0.0 };
            }
        }


        function getn1(u, v, ltemp, dl) {
            var la, lb, absa, absb, left, right;
            var vertexo, vertexa, vertexb, veca, vecb;
            la = ltemp;
            lb = ltemp;
            left = 0.0;
            right = 1.0;
            var i;
            vertexo = getv(u, v);
            vertexa = getv(u + la * dl[0], v + la * dl[1]);
            vertexb = getv(u + lb * dl[2], v + lb * dl[3]);
            veca = sub(vertexa, vertexo);
            vecb = sub(vertexb, vertexo);
            absa = norm(veca);
            absb = norm(vecb);
            if (absa > absb) {
                for (i = 0; i < 10; i++) {
                    la = ltemp * (left + right);
                    vertexa = getv(u + la * dl[0], v + la * dl[1]);
                    veca = sub(vertexa, vertexo);
                    absa = norm(veca);
                    if (absa > absb) {
                        right = 0.5 * (left + right);
                    }
                    else {
                        left = 0.5 * (left + right);
                    }
                }
            }
            else {
                for (i = 0; i < 10; i++) {
                    lb = ltemp * (left + right);
                    vertexb = getv(u + lb * dl[2], v + lb * dl[3]);
                    vecb = sub(vertexb, vertexo);
                    absb = norm(vecb);
                    if (absb > absa) {
                        right = 0.5 * (left + right);
                    }
                    else {
                        left = 0.5 * (left + right);
                    }
                }
            }
            vertexo = cross(veca, vecb);
            var odbl = 1.0 / sqrt(norm(vertexo));
            return { "x": vertexo.x * odbl, "y": vertexo.y * odbl, "z": vertexo.z * odbl };
        }


        function getr(u, v) {
            //return 1.0f;
            //return float(rand() % 256) / 256;
            return sin(v * 3.1416) / 2 + 0.5;
        }

        function getg(u, v) {
            //return 1.0f;
            //return float(rand() % 256) / 256;
            return sin(u * 3.1416) / 2 + 0.5;
        }

        function getb(u, v) {
            return 1.0;
            //return float(rand() % 256) / 256;
        }

        function getc(u, v) {
            return { "x": getr(u, v), "y": getg(u, v), "z": getb(u, v) };
        }

        window.onload = function () {
            cx = document.body.clientWidth;
            cy = document.body.clientHeight;
            document.getElementById("c1").setAttribute("width", cx);
            document.getElementById("c1").setAttribute("height", cy);
            var VSHADER_SOURCE =
                "#version 100 \n" +
                "precision highp float;\n" +
                "attribute vec3 vertex,normal,color;" +
                "varying vec4 fc;" +
                "varying vec4 a;" +
                "float l;" +
                "varying vec4 ntemp;" +
                "uniform mat4 view,project;" +
                "void main() {" +
                "   ntemp=vec4(normal,0.0);" +
                "	ntemp = view * ntemp;" +
                "   a=vec4(vertex,1.0);" +
                "	a = view* a;" +
                "	fc = vec4(color,1.0);" +
                "	gl_Position =  project*a;" +
                "}";

            var FSHADER_SOURCE =
                "#version 100 \n" +
                "precision highp float;\n" +
                "varying vec4 fc;" +
                "float s,t,u;" +
                "vec3 texdir;" +
                "varying vec4 a;" +
                "vec3 b,c;" +
                "varying vec4 ntemp;" +
                "void main(){" +
                "	b=vec3(a);" +
                "	b=normalize(b);" +
                "	c=vec3(ntemp);" +
                "	c=normalize(c);" +
                "	c=(gl_FrontFacing)?c:-c;" +
                "	texdir=reflect(b,c);" +
                "	s=texdir.x*0.276+texdir.y*0.920+texdir.z*0.276;" +
                "	t=c.x*0.276+c.y*0.920+c.z*0.276;" +
                "	t=0.5*t+0.46875*sqrt(t*t+0.137778);" +
                "	s=(s>0.0)?s:0.0;" +
                "	s=pow(s,4.0);" +
                "	s=s*0.54+t*0.40+0.05;" +
                "	s=pow(s,0.5);" +
                "	gl_FragColor.r = fc.r*s;" +
                "	gl_FragColor.g = fc.g*s;" +
                "	gl_FragColor.b = fc.b*s;" +
                "	gl_FragColor.a = fc.a;" +
                "}";
            gl = canvas.getContext("webgl");

            gl.enable(gl.DEPTH_TEST);

            vertshader = gl.createShader(gl.VERTEX_SHADER);
            fragshader = gl.createShader(gl.FRAGMENT_SHADER);
            shaderProgram = gl.createProgram();

            gl.shaderSource(vertshader, VSHADER_SOURCE);
            gl.compileShader(vertshader);
            var infov = gl.getShaderInfoLog(vertshader);

            gl.shaderSource(fragshader, FSHADER_SOURCE);
            gl.compileShader(fragshader);
            var infof = gl.getShaderInfoLog(fragshader);

            gl.attachShader(shaderProgram, vertshader);
            gl.attachShader(shaderProgram, fragshader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                var info = gl.getProgramInfoLog(shaderProgram);
                alert("Could not compile WebGL program.\n" + infov + infof + info);
            }
            glvertex = gl.getAttribLocation(shaderProgram, "vertex");
            glnormal = gl.getAttribLocation(shaderProgram, "normal");
            glcolor = gl.getAttribLocation(shaderProgram, "color");
            glview = gl.getUniformLocation(shaderProgram, "view");
            glproject = gl.getUniformLocation(shaderProgram, "project");

            gl.enableVertexAttribArray(glvertex);
            gl.enableVertexAttribArray(glnormal);
            gl.enableVertexAttribArray(glcolor);

            gl.viewport(0, 0, cx, cy);
            window.requestAnimationFrame(ontimer);

            sep();
            scan();
            var tric = 0;
            for (i = 0; i < points.length; i++) { tric += points[i] / 3; }
            alert("end:" + end + "\ntriangles:" + tric + "\ncreated by cznull@bilibili\nclick apply to generate a new model\nit will take several seconeds");

        }

        function draw() {
            mat = Array(16);
            mat[0] = cos(ang1);
            mat[1] = sin(ang1) * sin(ang2);
            mat[2] = -sin(ang1) * cos(ang2);
            mat[3] = 0.0;

            mat[4] = 0.0;
            mat[5] = cos(ang2);
            mat[6] = sin(ang2);
            mat[7] = 0.0;

            mat[8] = sin(ang1);
            mat[9] = -cos(ang1) * sin(ang2);
            mat[10] = cos(ang1) * cos(ang2);
            mat[11] = 0.0;

            mat[12] = -cenx*mat[0]-ceny*mat[4]-cenz*mat[8];
            mat[13] = -cenx*mat[1]-ceny*mat[5]-cenz*mat[9];
            mat[14] = -len-cenx*mat[2]-ceny*mat[6]-cenz*mat[10];
            mat[15] = 1.0;

            gl.uniformMatrix4fv(glview, false,new Float32Array(mat));

            var near = 0.01 * len;
            var far = 10.0 * len;

            mat[0] = (cx + cy) / cx / 2.0;
            mat[1] = 0.0;
            mat[2] =0.0;
            mat[3] = 0.0;

            mat[4] = 0.0;
            mat[5] =  (cx + cy) / cy / 2.0;;
            mat[6] = 0.0;
            mat[7] = 0.0;

            mat[8] = 0.0;
            mat[9] =0.0;
            mat[10] = -(near + far) / (far - near);
            mat[11] = -1.0;

            mat[12] = 0.0;
            mat[13] = 0.0;
            mat[14] = -near * far * 2.0 / (far-near);
            mat[15] = 0.0;
            gl.uniformMatrix4fv(glproject, false, new Float32Array(mat));
            for (var i = 0; i < points.length; i++) {
                if (points[i] > 2) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer[i]);
                    gl.vertexAttribPointer(glvertex, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, nbuffer[i]);
                    gl.vertexAttribPointer(glnormal, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, cbuffer[i]);
                    gl.vertexAttribPointer(glcolor, 3, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, points[i]);
                }
            }
            //gl.finish();
        }

        function clear() {
            for (var i = 0; i < vbuffer.length; i++) {
                gl.deleteBuffer(vbuffer[i]);
                gl.deleteBuffer(cbuffer[i]);
                gl.deleteBuffer(nbuffer[i]);
            }
            vbuffer = [];
            nbuffer = [];
            cbuffer = [];
            points = [];
        }

        canvas.addEventListener("mousedown",
            function (ev) {
                var oEvent = ev || event;
                if (oEvent.button == 0) {
                    ml = 1;
                    mm = 0;
                }
                if (oEvent.button == 2) {
                    mr = 1;
                    mm = 0;
                }
                mx = oEvent.clientX;
                my = oEvent.clientY;
            },
            false);

        canvas.addEventListener("mouseup",
            function (ev) {
                var oEvent = ev || event;
                if (oEvent.button == 0) {
                    ml = 0;
                }
                if (oEvent.button == 2) {
                    mr = 0;
                }
            },
            false);

        canvas.addEventListener("mousemove",
            function (ev) {
                var oEvent = ev || event;
                if (ml == 1) {
                    ang1 += (oEvent.clientX - mx) * 0.002;
                    ang2 += (oEvent.clientY - my) * 0.002;
                    if (oEvent.clientX != mx || oEvent.clientY != my) {
                        mm = 1;
                    }
                }
                if (mr == 1) {
                    var l = len * 4.0 / (cx + cy);
                    cenx += l * (-(oEvent.clientX - mx) * Math.cos(ang1) + (oEvent.clientY - my) * Math.sin(ang2) * Math.sin(ang1));
                    ceny += l * ((oEvent.clientY - my) * Math.cos(ang2));
                    cenz += l * (-(oEvent.clientX - mx) * Math.sin(ang1) - (oEvent.clientY - my) * Math.sin(ang2) * Math.cos(ang1));
                    if (oEvent.clientX != mx || oEvent.clientY != my) {
                        mm = 1;
                    }
                }
                mx = oEvent.clientX;
                my = oEvent.clientY;
            },
            false);

        canvas.addEventListener("mousewheel",
            function (ev) {
                ev.preventDefault();
                var oEvent = ev || event;
                len *= Math.exp(-0.001 * oEvent.wheelDelta);
            },
            false);

        canvas.addEventListener("touchstart",
            function (ev) {
                var n = ev.touches.length;
                if (n == 1) {
                    var oEvent = ev.touches[0];
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                }
                else if (n == 2) {
                    var oEvent = ev.touches[0];
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                    oEvent = ev.touches[1];
                    mx1 = oEvent.clientX;
                    my1 = oEvent.clientY;
                }
                lasttimen = n;
            },
            false);

        canvas.addEventListener("touchend",
            function (ev) {
                var n = ev.touches.length;
                if (n == 1) {
                    var oEvent = ev.touches[0];
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                }
                else if (n == 2) {
                    var oEvent = ev.touches[0];
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                    oEvent = ev.touches[1];
                    mx1 = oEvent.clientX;
                    my1 = oEvent.clientY;
                }
                lasttimen = n;
            },
            false);

        canvas.addEventListener("touchmove",
            function (ev) {
                ev.preventDefault();
                var n = ev.touches.length;
                if (n == 1 && lasttimen == 1) {
                    var oEvent = ev.touches[0];
                    ang1 += (oEvent.clientX - mx) * 0.002;
                    ang2 += (oEvent.clientY - my) * 0.002;
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                }
                else if (n == 2) {
                    var oEvent = ev.touches[0];
                    var oEvent1 = ev.touches[1];
                    var l = len * 2.0 / (cx + cy), l1;
                    cenx += l * (-(oEvent.clientX + oEvent1.clientX - mx - mx1) * Math.cos(ang1) + (oEvent.clientY + oEvent1.clientY - my - my1) * Math.sin(ang2) * Math.sin(ang1));
                    ceny += l * ((oEvent.clientY + oEvent1.clientY - my - my1) * Math.cos(ang2));
                    cenz += l * (-(oEvent.clientX + oEvent1.clientX - mx - mx1) * Math.sin(ang1) - (oEvent.clientY + oEvent1.clientY - my - my1) * Math.sin(ang2) * Math.cos(ang1));
                    l1 = Math.sqrt((mx - mx1) * (mx - mx1) + (my - my1) * (my - my1) + 1.0);
                    mx = oEvent.clientX;
                    my = oEvent.clientY;
                    mx1 = oEvent1.clientX;
                    my1 = oEvent1.clientY;
                    l = Math.sqrt((mx - mx1) * (mx - mx1) + (my - my1) * (my - my1) + 1.0);
                    len *= l1 / l;
                }
                lasttimen = n;
            },
            false);

        canvas.oncontextmenu = function (event) {
            if (mm == 1) {
                event.preventDefault();
            }
        };

        window.onresize = function () {
            cx = document.body.clientWidth;
            cy = document.body.clientHeight;
            document.getElementById("c1").setAttribute("width", cx);
            document.getElementById("c1").setAttribute("height", cy);
            gl.viewport(0, 0, cx, cy);
        }

        document.getElementById("kernel").value = s;

        document.getElementById("btn").addEventListener("click", function() {
            var state = this.innerText == "CONFIG";
            this.innerText = state ? "HIDE" : "CONFIG";
            document.getElementById("config").style.display = state ? "inline" : "none";
        });

        document.getElementById("apply").addEventListener("click", function () {
            s = document.getElementById("kernel").value;
            try {
                eval(s);
                getv(0.5, 0.5);
            }
            catch (e) {
                alert(e);
                return;
            }
            sep();
            scan();
            var tric = 0;
            for (i = 0; i < points.length; i++) { tric += points[i] / 3; }
            alert("end:" + end + "\ntriangles:" + tric);
        });

        document.getElementById("cancle").addEventListener("click", function() {
            document.getElementById("kernel").value = s;
        });</script>
</body>
</html>
